# Замыкания

Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена.

## Лексическая область видимости

Рассмотрим следующий пример:

```js
function init() {
    var name = "Mozilla"; // name - локальная переменная, созданная в init
    function displayName() { // displayName() - внутренняя функция, замыкание
        alert (name); // displayName() использует переменную, объявленную в родительской функции    
    }
    displayName();    
}
init();
```

`init()`создаёт локальную переменную`name`и определяет функцию`displayName()`.`displayName()`— это внутренняя функция — она определена внутри `init()` и доступна только внутри тела `init()`. Функция`displayName()`не имеет собственных локальных переменных и вместо этого использует переменную`name`, определённую в родительской функции. Однако точно такие же локальные переменные могут создаваться и использоваться внутри `displayName()`.

[https://jsfiddle.net/4o4z6fqn/9/](https://jsfiddle.net/78dg25ax/)

Выполните этот код и обратите внимание, что команда  `alert()` внутри `displayName()` благополучно выводит на экран содержимое переменной`name` объявленной в родительской функции. Это пример так называемой лексической области видимости_\(lexical scoping\)_: в JavaScript область действия переменной определяется по её расположению в коде \(это очевидно _лексически_\), и вложенные функции имеют доступ к переменным, объявленным вовне. Этот механизм и называется Lexical scoping \(область действия, ограниченная лексически\).

## Замыкание {#Замыкание}

Рассмотрим следующий пример:

```js
function makeFunc() {
  var name = "Mozilla";
  function displayName() {
    alert(name);
  }
  return displayName;
};

var myFunc = makeFunc();
myFunc();
```

Если выполнить этот код то результат будет такой же, как и выполнение `init()` из предыдущего примера: строка "Mozilla" будет показана в JavaScript alert диалоге. Что отличает этот код, и что представляет для нас интерес, так это то, что внутренняя функция displayName\(\) была возвращена из внешней до того, как была выполнена.

На первый взгляд кажется не очевидным что этот код правильный, но он работает. В некоторых языках программирования локальные переменные функции существуют только во время выполнения этой функции. После завершения выполнения `makeFunc()`можно ожидать, что переменная _name _больше не будет доступна. Однако, поскольку код продолжает нормально работать, очевидно что это не так в случае JavaScript.

Причина в том, что функции в JavaScript формируют так называемые _замыкания_. _Замыкание _— это комбинация функции и её лексического окружения в котором эта функция была объявлена. Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во время создания замыкания. В рассмотренном примере, `myFunc` — это ссылка на экземпляр функции `displayName` созданной в результате выполнения `makeFunc.` Экземпляр функции `displayName` в свою очередь сохраняет ссылку на своё лексическое окружение, в котором есть переменная `name`.  По этой причине, когда происходит вызов функции `myFunc`, переменная `name` остаётся доступной для использования и сохраненный в ней текст "Mozilla" передаётся в `alert`.

