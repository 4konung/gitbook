# Замыкания

Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена.

## Лексическая область видимости

Рассмотрим следующий пример:

```js
function init() {
    var name = "Mozilla"; // name - локальная переменная, созданная в init
    function displayName() { // displayName() - внутренняя функция, замыкание
        alert (name); // displayName() использует переменную, объявленную в родительской функции    
    }
    displayName();    
}
init();
```

`init()`создаёт локальную переменную`name`и определяет функцию`displayName()`.`displayName()`— это внутренняя функция — она определена внутри `init()` и доступна только внутри тела `init()`. Функция`displayName()`не имеет собственных локальных переменных и вместо этого использует переменную`name`, определённую в родительской функции. Однако точно такие же локальные переменные могут создаваться и использоваться внутри `displayName()`.

[https://jsfiddle.net/4o4z6fqn/9/](https://jsfiddle.net/78dg25ax/)

Выполните этот код и обратите внимание, что команда  `alert()` внутри `displayName()` благополучно выводит на экран содержимое переменной`name` объявленной в родительской функции. Это пример так называемой лексической области видимости_\(lexical scoping\)_: в JavaScript область действия переменной определяется по её расположению в коде \(это очевидно _лексически_\), и вложенные функции имеют доступ к переменным, объявленным вовне. Этот механизм и называется Lexical scoping \(область действия, ограниченная лексически\).

## Замыкание {#Замыкание}

Рассмотрим следующий пример:

```js
function makeFunc() {
  var name = "Mozilla";
  function displayName() {
    alert(name);
  }
  return displayName;
};

var myFunc = makeFunc();
myFunc();
```

Если выполнить этот код то результат будет такой же, как и выполнение `init()` из предыдущего примера: строка "Mozilla" будет показана в JavaScript alert диалоге. Что отличает этот код, и что представляет для нас интерес, так это то, что внутренняя функция displayName\(\) была возвращена из внешней до того, как была выполнена.

На первый взгляд кажется не очевидным что этот код правильный, но он работает. В некоторых языках программирования локальные переменные функции существуют только во время выполнения этой функции. После завершения выполнения `makeFunc()`можно ожидать, что переменная _name _больше не будет доступна. Однако, поскольку код продолжает нормально работать, очевидно что это не так в случае JavaScript.

