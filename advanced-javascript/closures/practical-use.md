## Замыкания на практике {#Замыкания_на_практике}

Замыкания полезны тем, что позволяют связать данные \(лексическое окружение\) с функцией, которая работает с этими данными. Очевидна параллель с объектно-ориентированным программированием, где объекты позволяют нам связать некоторые данные \(свойства объекта\) с одним или несколькими методами.

Следовательно, замыкания можно использовать везде, где вы обычно использовали объект с одним единственным методом.

Такие ситуации повсеместно встречаются в web-разработке. Большое количество front-end кода, который мы пишем на JavaScript, основан на обработке событий. Мы описываем какое-либо поведение, а потом связываем его с событием, которое создается пользователем \(например, клик мышкой или нажатие клавиши\). При этом наш код обычно привязывается к событию в виде обратного/ответного вызова \(callback\): _callback функция - функция выполняемая в ответ на возникновение события_.

Давайте рассмотрим практический пример: допустим, мы хотим добавить на страницу несколько кнопок, которые будут менять размер текста. Как вариант, мы можем указать свойство font-size на элементе body в пикселах, а затем —устанавливать размер прочих элементов страницы \(таких, как заголовки, например\) с использованием относительных единиц em:

```css
body {
  font-family: Helvetica, Arial, sans-serif;
  font-size: 12px;
}

h1 {
  font-size: 1.5em;
}

h2 {
  font-size: 1.2em;
}
```

Тогда наши кнопки будут менять свойство font-size элемента body, а остальные элементы страницы просто получат это новое значение и отмасштабируют размер текста, благодаря использованию относительных единиц.

Используем следующий JavaScript:

```js
function makeSizer(size) {
  return function() {
    document.body.style.fontSize = size + 'px';
  };
};

var size12 = makeSizer(12);
var size14 = makeSizer(14);
var size16 = makeSizer(16);
```

Теперь`size12`,`size14`, и `size16` — это функции, которые меняют размер текста в элементе body на значения 12, 14, и 16 пикселов, соответственно. После чего мы цепляем эти функции на кнопки примерно так:

```js
document.getElementById('size-12').onclick = size12;
document.getElementById('size-14').onclick = size14;
document.getElementById('size-16').onclick = size16;
```

```markdown
<a href="#" id="size-12">12</a>
<a href="#" id="size-14">14</a>
<a href="#" id="size-16">16</a>
```

[https://jsfiddle.net/fax46n3g/](https://jsfiddle.net/fax46n3g/)

## Эмуляция частных \(private\) методов с помощью замыканий {#Эмуляция_частных_(private)_методов_с_помощью_замыканий}

Языки вроде Java позволяют нам объявлять частные \(private\) методы . Это значит, что они могут быть вызваны только методами того же класса, в котором объявлены.

JavaScript не имеет встроенной возможности сделать такое, но это можно эмулировать с помощью замыкания. Частные методы полезны не только тем, что ограничивают доступ к коду, это также мощное средство глобальной организации пространства имен, позволяющее не засорять публичный интерфейс вашего кода внутренними методами классов.

Следующий код иллюстрирует, как можно использовать замыкания для определения публичных функций, которые имеют доступ к закрытым от пользователя \(private\) функциям и переменным. Такая манера программирования называется [модульным программировани](http://www.google.com/search?q=javascript+module+pattern)ем:

```js
var Counter = (function() {
  var privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment: function() {
      changeBy(1);
    },
    decrement: function() {
      changeBy(-1);
    },
    value: function() {
      return privateCounter;
    }
  };   
})();

alert(Counter.value()); /* Alerts 0 */
Counter.increment();
Counter.increment();
alert(Counter.value()); /* Alerts 2 */
Counter.decrement();
alert(Counter.value()); /* Alerts 1 */
```

Тут много чего поменялось. В предыдущем примере каждое замыкание имело свой собственный контекст исполнения \(окружение\). Здесь мы создаем единое окружение для трех функций: `Counter.increment`,`Counter.decrement`, и `Counter.value`.

Единое окружение создается в теле анонимной функции, которая исполняется в момент описания. Это окружение содержит два приватных элемента: переменную privateCounter и фукцию changeBy. Ни один из этих элементов не доступен напрямую, за пределами этой самой анонимной функции. Вместо этого они могут и должны использоваться тремя публичными функциями, которые возвращаются анонимным блоком кода \(anonymous wrapper\), выполняемым в той же анонимной функции.

Эти три публичные функции являются замыканиями, использующими общий контекст исполнения \(окружение\). Благодаря механизму lexical scoping в Javascript, все они имеют доступ к переменной `privateCounter` и функции `changeBy`.

Заметьте, мы описываем анонимную фунцию, создающую счетчик, и тут же запускаем ее, присваивая результат исполнения переменной `Counter`. Но мы также можем не запускать эту функцию сразу, а сохранить ее в отдельной переменной чтобы использовать для дальнейшего создания нескольких счетчиков вот так:

```js
var makeCounter = function() {
  var privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment: function() {
      changeBy(1);
    },
    decrement: function() {
      changeBy(-1);
    },
    value: function() {
      return privateCounter;
    }
  }  
};

var Counter1 = makeCounter();
var Counter2 = makeCounter();
alert(Counter1.value()); /* Alerts 0 */
Counter1.increment();
Counter1.increment();
alert(Counter1.value()); /* Alerts 2 */
Counter1.decrement();
alert(Counter1.value()); /* Alerts 1 */
alert(Counter2.value()); /* Alerts 0 */
```

Заметьте, что счетчики работают независимо друг от друга. Это происходит потому, что у каждого из них в момент создания функцией makeCounter\(\) также создавался свой отдельный контекст исполнения \(окружение\). То есть приватная переменная `privateCounter`в каждом из счетчиков это действительно отдельная самостоятельная переменная.

Используя замыкания подобным образом, вы получаете ряд преимуществ, обычно ассоциируемых с объектно-ориентированным программированием, таких как изоляция и инкапсуляция.

## Создание замыканий в цикле: Очень частая ошибка. {#Создание_замыканий_в_цикле_Очень_частая_ошибка.}

До того, как в версии ECMAScript 6 ввели ключевое слово [`let`](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Statements/let), постоянно возникала следующая проблема при создании замыканий внутри цикла. Рассмотрим следующий пример:

```markdown
<p id="help">Helpful notes will appear here</p>
<p>E-mail: <input type="text" id="email" name="email"></p>
<p>Name: <input type="text" id="name" name="name"></p>
<p>Age: <input type="text" id="age" name="age"></p>
```

```js
function showHelp(help) {
  document.getElementById('help').innerHTML = help;
}

function setupHelp() {
  var helpText = [
      {'id': 'email', 'help': 'Ваш адрес e-mail'},
      {'id': 'name', 'help': 'Ваше полное имя'},
      {'id': 'age', 'help': 'Ваш возраст (Вам должно быть больше 16)'}
    ];

  for (var i = 0; i < helpText.length; i++) {
    var item = helpText[i];
    document.getElementById(item.id).onfocus = function() {
      showHelp(item.help);
    }
  }
}

setupHelp();
```

[https://jsfiddle.net/fax46n3g/](https://jsfiddle.net/fax46n3g/)

Массив `helpText` описывает три подсказки для трех полей ввода. Цикл пробегает эти описания по очереди и для каждого из полей ввода определяет, что при возникновении события `onfocus` для этого элемента должна вызываться функция, показывающая соответствующую подсказку.

Если вы запустите этот код, то увидите, что он работает не так, как мы хотели. Какое поле вы бы не выбрали, в качестве подсказки всегда будет высвечиваться сообщение насчет возраста. Проблема в том, что функции, присвоенные как обработчики события  `onfocus`,  являются замыканиями. Они состоят из описания функции и контекста исполнения \(окружения\), унаследованного от  функции `setupHelp`. Было создано три замыкания, но все они были созданы с одним и тем же контекстом исполнения \(окружением\). К моменту возникновения события `onfocus` цикл уже давно отработал, а значит переменная `item`\(одна и та же для всех трех замыканий\) указывает на последний элемент массива, который как раз в поле возраста.

В качестве решения в этом случае можно предложить использование функции, фабричной функции \(function factory\), как уже было описано выше в примерах:

```js
function showHelp(help) {
  document.getElementById('help').innerHTML = help;
}

function makeHelpCallback(help) {
  return function() {
    showHelp(help);
  };
}

function setupHelp() {
  var helpText = [
      {'id': 'email', 'help': 'Ваш адрес e-mail'},
      {'id': 'name', 'help': 'Ваше полное имя'},
      {'id': 'age', 'help': 'Ваш возраст (Вам должно быть больше 16)'}
    ];

  for (var i = 0; i < helpText.length; i++) {
    var item = helpText[i];
    document.getElementById(item.id).onfocus = makeHelpCallback(item.help);
  }
}

setupHelp();
```

[http://jsfiddle.net/pv392bc3/](http://jsfiddle.net/pv392bc3/)

Вот это работает как следует. Вместо того, чтобы делить на всех одно окружение, функция `makeHelpCallback` создает каждому из замыканий свое собственное, в котором переменная item указывает на правильный элемент массива `helpText`.

