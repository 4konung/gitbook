# Событийный цикл

Параллелизм в JavaScript основывается на модели "событийного цикла". Эта модель отличается от модели других языков, например C или Java.

### Стек {#Стек}

Вызов любой функции создает контекст выполнения. При вызове вложенной функции создается новый контекст, а старый сохраняется в специальной структуре. Так формируется стек контекстов.

```js
function f(b) {
  var a = 12;
  return a + b + 35;
}

function g(x) {
  var m = 4;
  return f(m * x);
}

g(21);
```

Когда вызывается`g`,  создаётся область видимости, содержащая аргументы`g`и локальные переменные. Когда`g`вызывает`f`, создаётся вторая область видимости и помещается в стек вперед первой, которая содержит аргументы`f`и её локальные переменные. Когда`f`возвращает результат, верхний элемент из стека удаляется. Когда`g`возвращает результат, ее контекст также удалится, и стек будет пуст.

### Куча {#Куча}

Объекты размещаются в [куче](https://ru.wikipedia.org/wiki/%D0%9A%D1%83%D1%87%D0%B0_%28%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C%29). Куча — это ссылка на определённую неструктурированную область памяти.

### Очередь {#Очередь}

Среда выполнения JavaScript содержит очередь событий. Очередь событий — это список событий, подлежащих обработке. Каждое событие ассоциируется с некоторой функцией. Когда на стеке освобождается достаточно места, событие извлекается из очереди и обрабатывается. Обработка события состоит в вызове  этой функции \(и, таким образом, создании начального контекста выполнения\). Обработка события заканчивается, когда стек снова становится пустым.

## Цикл событий {#Цикл_событий}

Модель событийного цикла \(`event loop`\) называется так потому, что отслеживает новые события в цикле:

```js
while(queue.waitForMessage()){
  queue.processNextMessage();
}
```

`queue.waitForMessage`ожидает события если очередь пуста.

### Запуск до завершения {#Запуск_до_завершения}

Каждое событие должно быть полностью обработано прежде, чем начнет обрабатываться следующее. Благодаря этому мы можем точно знать: когда бы и где бы не выполнялась функция – она не может быть приостановлена и будет целиком завершена до начала выполнения другого кода \(который может изменять данные, с которыми работает текущая функция\). Это отличает JavaScript от такого языка программирования как C. Поскольку в С функция, запущенная в отдельном потоке, в любой момент может быть остановлена, чтобы выполнить какой-то другой код в другом потоке.

У данного подхода есть и минусы. Если событие обрабатывается слишком долго, то приложение в это время не имеет возможности обработать действия пользователя \(например, скролл или клик\). Браузер может смягчать последствия такой проблемы. Internet Explorer в таком случае выводит сообщение _"A script on this page is causing Internet Explorer to run slowly" _и предлагает завершить обработку слишком тяжелого события. Хорошая практика для предохранения от этого – не создавать события, которые могут выполняться долго и разбивать большие события на несколько мелких.

### Добавление событий в очередь {#Добавление_событий_в_очередь}

В браузерах события добавляются в очередь в любое время, если событие произошло, а так же если у него есть обработчик. В случае, если обработчика нет – событие потеряно. Так, клик по элементу, имеющему обработчик события по событию`click`, добавит событие в очередь, а если обработчика нет – то и событие в очередь не попадет.

Вызов [setTimeout](https://developer.mozilla.org/ru/docs/Web/API/WindowTimers/setTimeout) добавит событие в очередь по прошествии времени, указанного во втором аргументе вызова. Если очередь событий на тот момент будет пуста, то событие обработается сразу же, в противном случае событию функции `setTimeout` придется ожидать завершения обработки остальных событий в очереди. Именно поэтому второй аргумент `setTimeout` корректно считать не временем, через которое выполнится функция из первого аргумента, а минимальное время, через которое она сможет выполниться.

