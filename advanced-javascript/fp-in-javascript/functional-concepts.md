# Концепции функционального программирования в Javascript

### Чистота {#019e}

#### Чистые функции {#2237}

Возвращаемое значение чистой функции зависит только от ее входных данных \(аргументов\) и не влечет никаких побочных эффектов. С одним и тем же входящим аргументом результат всегда будет одинаковый. Пример:

```js
function half(x) {
    return x / 2;
}
```

Функция`half(x)`принимает число`x`и возвращает значение половины`x`. Если мы передадим этой функции аргумент `8`, она вернет `4`. После вызова чистая функция всегда может быть заменена результатом своей работы. Например, мы могли бы заменить`half(8)`на `4`: где бы эта функция не использовалась в нашем коде, подмена никак не повлияла бы на конечный результат. Это называется [ссылочной прозрачностью](https://ru.wikipedia.org/wiki/Чистота_языка_программирования).

Чистые функции зависят только от того, что им передано. Например, чистая функция не может ссылаться на переменные из области видимости родителя, если они явно не передаются в нее в качестве аргументов. Но и даже тогда функция не может изменять что-либо в родительской области видимости.

```js
var someNum = 8;

// это НЕ чистая функция
function impureHalf() {
  return someNum / 2;
}
```

Итого:

* Чистые функции должны принимать аргументы.
* Одни и те же входные данные \(аргументы\) всегда произведут одинаковые выходные данные \(вернут одинаковый результат\).
* Чистые функции основываются только на внутреннем состоянии и не изменяют внешнее \(_примечание:`console.log`изменяет глобальное состояние_\).
* Чистые функции не производят [побочных эффектов](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B1%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D1%8D%D1%84%D1%84%D0%B5%D0%BA%D1%82_%28%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%29).
* Чистые функции не могут вызывать нечистые функции.

#### Нечистые функции {#8814}

Нечистая функция изменяет состояние вне своей области видимости. Любые функции с _побочными эффектами_ — нечистые, ровно как и процедурные функции без возвращаемого значения. Рассмотрим следующие примеры:

```js
// нечистая функция производит побочный эффект
function showAlert() {
  alert('This is a side effect!');
}
// нечистая функция изменяет внешнее состояние
var globalVal = 1;
function incrementGlobalVal(x) {
  globalVal += x;
}
// нечистая функция процедурно вызывает чистую фунцию
function proceduralFn() {
  const result1 = pureFnFirst(1);
  const result2 = pureFnLast(2);
  console.log(`Done with ${result1} and ${result2}!`);
}
// нечистая функция выглядит чистой,
// но возвращает разные значения
// при одинаковых входных данных
function getRandomRange(min, max) {
  return Math.random() * (max - min) + min;
}
```

#### Побочные эффекты в JavaScript {#5a71}

Когда функция или выражение изменяет состояние вне своего контекста, результат является побочным эффектом. Примеры побочных эффектов: вызов API, манипулирование DOM, вывод alert, запись в базу данных и так далее. Если функция производит побочные эффекты, она считается _нечистой_. Функции, вызывающие побочные эффекты, менее предсказуемы и их труднее тестировать, поскольку они приводят к изменениям вне их локальной области видимости.

#### Вывод

Много качественного кода состоит из нечистых функций, процедурно вызывающихся чистыми. Это все равно несет массу преимуществ для тестирования и неизменяемости. Ссылочная прозрачность также обладает удобством для [мемоизации](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%BC%D0%BE%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F): кэширование и сохранение результатов вызова функций, а затем [переиспользование кэшированных результатов](https://www.sitepoint.com/implementing-memoization-in-javascript/). Однако определить, когда функции действительно чисты, может быть непросто.

### Состояние {#8733}

Состояние — информация, к которой программа имеет доступ и с которой может работать в определенный момент времени. Сюда входят данные, хранящиеся в памяти, порты ввода/вывода, базы данных и так далее. Например, содержимое переменных в приложении в любой данный момент времени репрезентативно для состояния приложения.

#### С состоянием {#5a86}

Программы, приложения или компоненты с состоянием хранят в памяти данные о текущем состоянии. Они могут изменять состояние, а также имеют доступ к его истории. Следующий пример демонстрирует это:

```js
var number = 1;
function increment() {
  return number++;
}
// глобальная переменная изменяется: number = 2
increment();
```

#### Без состояния {#8f49}

Функции или компоненты без состояния выполняют задачи, словно каждый раз их запускают впервые. Они не ссылаются или не используют в своем исполнении раннее созданные данные. Отсутствие состояния обеспечивает ссылочную прозрачность. Функции зависят только от их аргументов и не имеют доступа, не нуждаются в знании чего-либо вне их области видимости.[Чистые функции](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D1%82%D0%BE%D1%82%D0%B0_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8) не имеют состояния. Пример:

```js
var number = 1;
function increment(n) {
  return n + 1;
}
// глобальная переменная НЕ изменяется: возвращает 2
increment(number);
```

Приложения без состояния все еще управляют состоянием. Однако они возвращают свое текущее состояние без изменения предыдущего состояния. Это принцип [функционального программирования](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5).

#### Вывод

Управление состоянием важно для любого сложного приложения. Функции или компоненты с состоянием изменяют состояние и его историю, их труднее тестировать и отлаживать. Функции без состояния полагаются только на свои входные данные для создания данных выходных. Программа без состояния возвращает новое состояние, а не модифицирует существующее состояние.

### Неизменяемость и изменяемость {#9783}

Концепции неизменяемости и изменяемости более туманны в JavaScript, чем в некоторых других языках программирования. Тем не менее, вы много услышите о неизменяемости при чтении о функциональном программировании в JS. Важно знать, что эти термины означают в классическом понимании, и как они реализуются в JavaScript. Определения достаточно просты:

#### Неизменяемый {#9a76}

Если объект является неизменяемым, его значение не может быть изменено после создания.

#### Изменяемый {#a379}

Если объект изменяем, его значение может быть изменено после создания.

#### Реализация: неизменяемость и изменяемость в JavaScript {#3f0b}

В JavaScript строки и числовые литералы реализованы неизменяемыми. Это легко понять, если рассмотреть, как мы работаем с ними:

```js
var str = 'Hello!';
var anotherStr = str.substring(2);
// результат: str = 'Hello!' (не изменена)
// результат: anotherStr = 'llo!' (новая строка)
```

Используя метод `.substring()`на нашем`Hello!`, строка не изменяет исходную строку. Вместо этого она создает новую строку. Мы могли бы переопределить значение переменной`str`на что-то другое, но, как только мы создали нашу строку`Hello!`, она навсегда останется`Hello!`

Числовые литералы также неизменяемы. Следующий пример всегда будет иметь одинаковый результат:

```js
var three = 1 + 2;
// результат: three = 3
```

Ни при каких обстоятельствах `1 + 2 `не может стать чем-либо, кроме `3`.

