# Контекст выполнения

Поведение ключевого слова `this` в  JavaScript несколько отличается по сравнению с остальными языками. Имеются также различия при использовании `this` в [строгом](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) и нестрогом режиме.

В большинстве случаев значение `this` определяется тем, каким образом вызвана функция. Значение `this`не может быть установлено путем присваивания во время исполнения кода и может иметь разное значение при каждом вызове функции. В ES5 представлен метод [`bind`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind), чтобы [определить значение ключевого слова this независимо от того, как вызвана функция](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this$translate?tolocale=ru#The_bind_method). Также в ECMAScript 2015 представлены [стрелочные функции](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions), this которых привязан к окружению, в котором была создана стрелочная функция.

---

## Глобальный контекст {#Глобальный_контекст}

В глобальном контексте выполнения \(за пределами каких-либо функций\),`this` ссылается на глобальный объект вне зависимости от использования в строгом или нестрогом режиме.

```js
console.log(this.document === document); // true

// В браузерах, объект window также является глобальным:
console.log(this === window); // true

this.a = 37;
console.log(window.a); // 37
```

---

## В контексте функции {#В_контексте_функции}

В пределах функции значение `this` зависит от того, каким образом вызвана функция.

### Простой вызов {#Простой_вызов}

В этом случае значение `this` не устанавливается вызовом. Так как этот код написан не в строгом режиме, значением `this` всегда должен быть объект, по умолчанию - глобальный объект.

```js
function f1(){
  return this;
}
// В браузере
f1() === window; // window глобальный объект в браузере
```

В строгом режиме, значение `this` остается тем значением, которое было установлено в контексте исполнения. Если такое значение не определено, оно остается undefined.

```js
function f2(){
  "use strict"; // see strict mode
  return this;
}

f2() === undefined;
```

Итак, в строгом режиме если this не определено оно остается не определено.

Для того что бы передать значение this от одного контекста другому необходимо использовать [call](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call) или [apply](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)

### Стрелочные функции {#Стрелочные_функции}

В [стрелочных функциях](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions), `this` привязан к окружению, в котором была создана функция. В глобальной области видимости, `this` будет указывать на глобальный объект.

```js
var globalObject = this;
var foo = (() => this);
console.log(foo() === globalObject); // true
```

Не важно, как функция `foo()`будет вызвана, ее this будет указывать на глобальный объект.`this` будет сохранять свое значение, даже если функция `foo()`будет вызвана как метод объекта \(что в обычных функциях связывает  `this` с объектом вызова\) или с использованием методов `call`,`apply`или`bind`:

```js
// Вызов функции как метода объекта
var obj = {foo: foo};
console.log(obj.foo() === globalObject); // true

// Попытка установить this с помощью call
console.log(foo.call(obj) === globalObject); // true

// Попытка установить this с помощью bind
foo = foo.bind(obj);
console.log(foo() === globalObject); // true
```

Независимо от этого, `this` функции `foo()`имеет тоже значение, что и при создании функции \(глобальный объект в примере выше\). То же самое касается стрелочных функций созданных внутри других функций: их `this` будет привязан к окружению.

```js
// Создаем объект obj с методом bar который возвращает функцию
// которая возвращает свой this. Возвращаемая функция создана
// как стрелочная функция, таким образом ее this замкнут 
// на this функции в которой она создана. 
var obj = { bar : function() {
                    var x = (() => this);
                    return x;
                  }
          };

// Вызываем bar как метод объекта obj, устанавливая его this на obj
// Присваиваем ссылку возвращаемой функции fn
var fn = obj.bar();

// Вызываем fn без установки this, что в обычных функциях указывало бы
// на глобальный объект или undefined в строгом режиме.
console.log(fn() === obj); // true
```

В примере выше, функция \(назовем ее анонимной функцией A\) присвоенная  `obj.bar` возвращает другую функцию \(назовем ее анонимной функцией B\) которая создана как стрелочная функция. В результате вызова функции A, `this функции B замкнут на this,` принадлежащий `obj.bar` \(функции A\). `this` функции B всегда будет иметь то значение которое он получил при создании. В примере выше, `this функции B` указывает на `this функции A, который указывает на` obj, таким образом this будет указывать на `obj` даже когда будет вызван методом который в нормальных условиях устанавливал значение this равным `undefined или глобальному обьекту` \( или любым другим методом, как в предыдущих примерах\).

### В методе объекта {#В_методе_объекта}

Когда функция вызывается как метод объекта, используемое в этой функции ключевое слово `this` принимает значение объекта, по отношению к которому вызван метод.

В следующем примере,  когда вызвано свойство `o.f()`, внутри функции `this` привязано к объекту `o.`

```js
var o = {
  prop: 37,
  f: function() {
    return this.prop;
  }
};

console.log(o.f()); // logs 37
```

Необходимо отметить, что  на поведение this совсем не влияет то, как или где была определена функция.  В предыдущем примере мы определили функцию внутри свойства  `f` во время определения объекта `o`. Однако, мы могли бы также просто определить сначала функцию, а затем закрепить ее за за свойством `o.f`. В этом случае поведение this не изменится:

```js
var o = {prop: 37};

function independent() {
  return this.prop;
}

o.f = independent;

console.log(o.f()); // logs 37
```

Эти примеры показывают, что имеет значение только то, что функция была вызвана из свойства `f` объекта `o`.

Аналогично, привязывание `this`  обуславлавливается наличием ближайшей ссылки  на объект или свойство. В следующем примере, когда мы вызываем функцию, мы обращаемся к ней как к методу `g` объекта `o.b`. На этот раз во время выполнения, `this,` что находится внутри функции, будет ссылаться на `o.b`.  Тот факт, что объект является членом объекта `o` не имеет значения; важна только ближайшая ссылка.

```js
o.b = {g: independent, prop: 42};
console.log(o.b.g()); // logs 42
```

#### `this`в цепочке object's prototype  {#this_в_цепочке_object's_prototype}

Это же представление справедливо и для методов, определенных где-либо в цепочке object's prototype. Если метод находится в цепочке прототипов, то this ссылается на объект, на котором был вызван метод, т.е. так, словно метод является методом самого объекта, а не прототипа. 

```js
var o = {f:function(){ return this.a + this.b; }};
var p = Object.create(o);
p.a = 1;
p.b = 4;

console.log(p.f()); // 5
```

В этом примере, объект, которому присвоена переменная `p,` не имеет собственного свойства `f`, а наследует это свойство от своего прототипа. Однако, совершенно неважно, что поиск свойства f в конце концов обнаружит его на объекте `o`. Поскольку поиск начался с `p.f`, то и свойство `this` внутри функции `f`будет ссылаться на объект`p`. Таким образом, если `f` вызывается как метод `p`, то и `this` относится к `p`. Это полезная особеность прототипного наследования JS.

