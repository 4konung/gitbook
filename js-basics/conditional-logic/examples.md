## Задание №1

_Какое значение будет в консоли и почему ?_

```js
var array = [0];

if (array) {
  console.log(array == false);
}
```

В данном примере была объявлена переменная `array` в которую записан массив с одним элементом, числом `0` . Далее следует условный оператор и массив `array` в качестве условия. При _верном_ условии выполнится сравнение массива с false, и результат выведется в консоли.

Можно предположить, что если массив _непустой, _то и условие в if выполнится, и мы попадем в блок, в котором еще раз проверим, чему равен массив при сравнении с каким-либо логическим значением, в данном примере с false. И учитывая, что в блок мы уже попали, то массив никак не может быть _false._ Соответственно ответ: в консоли будет _false,_ массив это _true _и _true !== false._

Правильный же ответ - в консоли будет _true._

Разберём по порядку. Условный оператор if и массив. Мы предположили, что если массив непустой и в нем что-то есть, то и в условном операторе он даст _true_, и код внутри блока будет выполнен.

```js
var arrayWithValues = [1, 2, 'red'];

if (arrayWithValues) {
  console.log('Worked, array with values is true for "if condition"')
} else {
  console.log('Not working, array with values is false for "if condition"')
}
```

Значит, пустой массив в условном операторе выдает _false _и код внутри блока не выполнится, верно ?

```js
var emptyArray = [];

if (emptyArray) {
  console.log('Worked, empty array is true for "if condition"')
} else {
  console.log('Not working, empty array is false for "if condition"')
}
```

Но в консоли будет _Worked, empty array is true for "if condition"._ Получается, что массив, даже пустой, является _true _для условного оператора. То же самое применимо и к объектам, причем всем. Правильнее утверждать, что все объекты дадут результат true для условного оператора, а так как массив тоже является объектом, то он _true_. Учитывая, что все объекты по умолчанию наследуются от базового Object.prototype, то правило, что объект возвращает true в условном операторе if, действительно применимо для всех без исключения объектов и его наследников, будь то экземпляры встроенных в язык _классов _типа Array, Function или Date, или же экземпляры пользовательских _классов._

Если массив в любом случае `true` то почему в консоли при сравнение массив с `false` true. При сравнение с помощью операторов типа ==, !=, =! и т.д происходит приведение типов. Связано это с тем что мы пытаемся сравнить два значения, но для начала надо чтобы эти два значения были одинакового типа. Поэтому происходит следующее:

```js
[0] == false; // true
```

1. Сравнивать мы можем только примитивы, т е примитивные значения: строки, числа, логический тип. Массив это объект поэтому его надо превратить в примитив, например строку. `[ 0 ] => " 0 " .`  Получим строковое представление массива. 
2. Сравнить строку `"0"` с _false _мы всё еще не можем - разные типы - строка и boolean. Приводим строку в число.`"0" => 0` .
3. Сравнить число `0` с false мы тоже не можем - разные типы - число и boolean. Приводим false к числу,  _false _это 0
4. Сравниваем 0 c 0. 0 == 0. Отсюда и ответ true.

При использовании строго равенства с помощью оператора `===` ответ будет другим так как типы разные.

```js
[0] === false; // false
```



