## Приведение типов

??? возможно должно быть здесь



## Истина и ложь

Особый список "ложных" значений в JavaScript таков:

* `""`\(пустая строка\)
* `0`,`-0`,`NaN`\(некорректное`число`\)
* `null`,`undefined`
* `false`

Любое значение, не входящее в этот "ложный" список — "истинно." Вот несколько примеров:

* `"hello"`
* `42`
* `true`
* `[ ]`,`[ 1, "2", 3 ]`\(массивы\)
* `{ }`,`{ a: 42 }`\(объекты\)
* `function foo() { .. }`\(функции\)

Важно помнить, что не-`boolean`значение следует такому приведению "истинный"/"ложный" только если оно действительно приводится к`boolean`. Это — не единственная трудность, которая может смутить вас в ситуации, когда кажется что есть приведение значения к`boolean`, когда на самом деле его нет.

## Равенство

Есть четыре операции равенства:`==`,`===`,`!=`и`!==`. Формы с`!`— конечно же, симметричные версии "не равно" своих противоположностей; _не равно _не следует путать с _неравенством_.

Разница между`==`и`===`— обычно состоит в том, что`==`проверяет на равенство значений, а`===`проверяет на равенство и значений, и типов. Однако, это не точно. Подходящий способ охарактеризовать их:`==`проверяет на равенство значений с использованием приведения, а`===`проверяет на равенство не разрешая приведение. Операцию`===`часто называют "строгое равенство" по этой причине.

Пример неявного приведения, которое допускается нестрогим равенством`==`и не допускается строгим равенством`===`:

```js
var a = "42";
var b = 42;

a == b;			// true
a === b;		// false
```

В сравнении`a == b`JS замечает, что типы не совпадают, поэтому он делает упорядоченный ряд шагов, чтобы привести одно или оба значения к различным типам, пока типы не совпадут, а затем уже может быть проверено простое равенство значений.

Если подумать, то есть два возможных пути, когда`a == b`может стать`true`через приведение. Либо сравнение может закончится на`42 == 42`, либо на`"42" == "42"`. Так какое же из них?

Ответ:`"42"`становится`42`, чтобы сделать сравнение`42 == 42`. В таком простом примере не так уж важно по какому пути пойдет сравнение, в конце результат будет один и тот же. Есть более сложные случаи, где важно не только каков конечный результат сравнения, но и _как _вы к нему пришли.

Сравнение`a === b`даст`false`, так как приведение не разрешено, поэтому простое сравнение значений очевидно не завершится успехом. Многие разработчики чувствуют, что операция`===`— более предсказуема, поэтому они советуют всегда использовать эту форму и держаться подальше от`==`. Думаю, такая точка зрения очень недальновидна.

Чтобы свести целое множество деталей к нескольким простым мыслям и помочь вам узнать, использовать ли`==`

или`===`в различных ситуациях:

Если одно из значений \(т.е. сторона\) в сравнении может быть значением

* `true`или`false`, избегайте`==`и используйте`===`.
* Если одно из значений в сравнении может быть одним из этих особых значений \(`0`,`""`или`[]`— пустой массив\), избегайте`==`и используйте`===`.
* Во _всех _остальных случаях, вы можете безопасно использовать`==`. Это не только безопасно, но во многих случаях это упрощает ваш код путем повышения читаемости.

Эти правила сводятся к тому, что требуют от вас критически оценивать свой код и думать о том, какого вида значения могут исходить из переменных, которые проверяются на равенство. Если вы уверены насчет значений `==`безопасна, используйте ее! Если вы не уверены насчет значений, используйте`===`

.

